/* time to wait between each loop pass, in ms */
#define WAIT_INTERVAL 20

/* time limitation in seconds */
#define TIME_LIMIT 240
/* time to ge tto the base */
#define CRITICAL_TIME 180

/* touch sensor left */
#define SENSOR_T_L IN_1
/* touch sensor right */
#define SENSOR_T_R IN_2
/* light sensor */
#define SENSOR_L IN_3
/* ultrasonic sensor */
#define SENSOR_US IN_4

/* engine left */
#define ENGINE_L OUT_A
/* engine right */
#define ENGINE_R OUT_B
/* both engines */
#define ENGINE_B OUT_AB
/* combine harvester engine */
#define ENGINE_H OUT_C

/* harvester spinning speed */
#define HARVESTER_SPEED 100

/* Some range levels */
#define DISTANT_RANGE 55
#define WARNING_RANGE 35
#define EMERGENCY_RANGE 25
/* the duration of the reverse gear when an obstacle is seen, in ms */
#define OBSTACLE_BACKWARDS_DURATION 500

/* The refine the precision, change theese */
#define L_DARK_THRESHOLD 30
#define L_WHITE_THRESHOLD 50
/* the duration of the reverse gear when the white line is seen, in ms */
#define LINE_BACKWARDS_DURATION 1000

/* Motion calculation values (in meters) */
#define WHEEL_RADIUS 0.08
#define WHEELS_SPACING 0.129

/* Motion speed values */
#define REGULAR_SPEED 100
#define LOW_SPEED 75
#define ROTATION_SPEED 50

/* Angle sensivity in degrees */
#define ANGLE_SENSIVITY 10

/* Rotation PID */
#define R_PID_P PID_5
#define R_PID_I PID_5
#define R_PID_D PID_2

enum EStatus {STATUS_START, STATUS_RUNNING};

/* global sound infos, because it's i nanother task */
typedef struct {
	unsigned int current;
	bool loop;
} Sound_Infos;
/* Global variable to specify which sound is played
Possible values are:
0 no sound,
1 Ambient sound,
2 Obstacle dodge sound,
3 Finish sound
*/
Sound_Infos sound_infos;

/* a structure to compute the position */
typedef struct {
	float speed, last_speed;
	unsigned long last_tick;
} Pos_Computation;

/* a structure to hold the position data, and to help with the computation */
typedef struct {
	float angle;/* must ALWAYS be between 0 and 359.99999999999999999 */
	float x, y;
} Coords;

void zero_coords(Coords coords) {
	coords.angle = 0;
	coords.x = 0;
	coords.y = 0;
}

void zero_p_comp(Pos_Computation p_comp) {
	p_comp.speed = 0;
	p_comp.last_speed = 0;
	p_comp.last_tick = 0;
}

/* When need to convert the angular speed to the actual speed of the robot, assuming both of the wheels have the same speed */
float motor_speed_to_speed(char motor_speed) {
	return WHEEL_RADIUS * motor_speed;
}

/* we need to have a relation between the wheels angles and the robot angle */
float angle_to_motor_angle(float angle) {
	return angle * WHEELS_SPACING / WHEEL_RADIUS;
}

void update_pos(Coords coords, Pos_Computation p_comp) {
	unsigned long tick = CurrentTick(), dt;

	dt = tick - p_comp.last_tick;
	p_comp.last_tick = tick;

	coords.x += cos(coords.angle) * dt * p_comp.speed;
	coords.y += sin(coords.angle) * dt * p_comp.speed;
}

/* changing the speed computes the ne position if needed */
/* we assume that the both wheels are spinning at the same speed */
/* This function is used to go strait ahead */
void set_speed(Coords coords, Pos_Computation p_comp, char new_motor_speed) {
	update_pos(coords, p_comp);
	
	if(new_motor_speed != p_comp.speed) {
		p_comp.last_speed = p_comp.speed;
		p_comp.speed = motor_speed_to_speed(new_motor_speed);

		if(new_motor_speed != 0) {
			OnFwdSync(ENGINE_B, new_motor_speed, 0);
		} else {
			Off(ENGINE_B);
		}
	}
}

/* Positive motor angle : rotate right */
/* The motors SHOULD be stopped  beforce calling this function*/
void do_rotation(float motor_angle) {
	OnFwdSync(ENGINE_B, ROTATION_SPEED, 0);
	/*RotateMotor(ENGINE_R, ROTATION_SPEED, motor_angle);
	RotateMotor(ENGINE_L, ROTATION_SPEED, -motor_angle);*/

	/* TODO: PID modified with angle? */
	RotateMotorExPID(ENGINE_B, ROTATION_SPEED, motor_angle, 100, true, true, R_PID_P, R_PID_I, R_PID_D);
}

/* Motion relative functions, they all update the position */
/* absolute angle, from the x and y pos and the current angle */
void set_angle(Coords coords, Pos_Computation p_comp, float new_angle) {
	float angle_difference, motor_angle;

	if(coords.angle - ANGLE_SENSIVITY < new_angle && new_angle < coords.angle + (360 - ANGLE_SENSIVITY)) {/* No need to interrupt the motion */
		/* Need to stop the wheels */
		set_speed(coords, p_comp, 0);

		angle_difference = ((new_angle - coords.angle) % 360);

		/* Need to check the faster way to rebackwardsach the angle */
		/* between 0 and 180 -> turn left */
		if(new_angle > 0 && new_angle < 180) {
			motor_angle = angle_to_motor_angle(-angle_difference);
		} else {/* between 180 and 360 -> turn right*/
			motor_angle = angle_to_motor_angle(angle_difference);
		}
		do_rotation(motor_angle);
		coords.angle = new_angle;
	}
}

void sensors_setup() {
	SetSensorTouch(SENSOR_T_L);
	SetSensorTouch(SENSOR_T_R);
	SetSensorLight(SENSOR_L);
	SetSensorUltrasonic(SENSOR_US);
}

/* Checks the obstacles sensors status :
returns 0 when no obstacle
returns 1 when collision on the left
returns 2 when collision on the right
returns 3 when distant obstacle
returns 4 when obstacle warning
returns 5 when obstacle emergency
/* We assume that this function is called often enough in order not to calculate the average on all the sensors values */
/* In my opinion, the robot should behave the same way when the range is lower than 20 cm or when a touch sensor is activated,
to do an « emergency obstacle dodge. */
/* But, how do we know if the obstacle is on the right or on the left ? This should be to investigate */
int obstacle_sensors_status() {
	int a;

	/* Touch sensors, the important ones */
	a = Sensor(SENSOR_T_L);
	if(a) {
		return 1;
	}

	a = Sensor(SENSOR_T_R);
	if(a) {
		return 2;
	}

	/* Ultrasonic sensor */
	a = SensorUS(SENSOR_US);
	if(a < EMERGENCY_RANGE) {
		return 5;
	} else if(a < WARNING_RANGE) {
		return 4;
	} else if(a < DISTANT_RANGE) {
		return 3;
	}

	return 0;
}

/* Checks the light sensor:
returns 0 when everything is good,
returns 1 when in the starting area,
returns 2 when detecting the white line */
int light_sensor_status() {
	int a;

	a = Sensor(SENSOR_L);
	if(a < L_DARK_THRESHOLD) {
		return 1;
	} else if(a > L_WHITE_THRESHOLD) {
		return 2;
	}

	return 0;
}

/* Start the harvester */
void start_harvesting() {
	OnFwd(ENGINE_H, HARVESTER_SPEED);
}

void stop_harvesting() {
	Off(ENGINE_H);
}

task PlaySoundTask() {
	string s_file;
	bool ok = true;
	unsigned long w = 0;

	switch(sound_infos.current) {
		case 1:
			s_file = "rick.rso";
			w = TIME_LIMIT * 1000;
			break;

		case 2:
			s_file = "queen.rso";
			w = 3000;
			break;

		case 3:
			s_file = "dessert.rso";
			w = 1500;
			break;

		default:
			w = 0;
			ok = false;
			break;
	}

	if(ok) {
		PlayFileEx(s_file, 4, sound_infos.loop);
		Wait(w);
	}
	sound_infos.current = 0;
}

void stop_sound() {
	if(sound_infos.current) {
		StopTask(PlaySoundTask);
		sound_infos.current = 0;
	}
}

void play_sound(unsigned int sound, bool loop) {
	if(sound_infos.current) {
		stop_sound();
	}
	if(sound) {
		sound_infos.current = sound;
		sound_infos.loop = loop;
		StartTask(PlaySoundTask);
	}
}

task main() {
	unsigned long elapsed_time, first_tick;
	Coords coords;
	Pos_Computation p_comp;
	EStatus status = STATUS_START;
	int sensor, r;
	bool skip, break_loop = false;

	sound_infos.current = 0;

	zero_coords(coords);
	zero_p_comp(p_comp);
	
	sensors_setup();

	set_angle(coords, p_comp, 270);

	/*start_harvesting();*/

	elapsed_time = 0;/* in seconds */
	first_tick = CurrentTick();
	while(false && elapsed_time < TIME_LIMIT && !break_loop) {
		skip = false;

		if(sound_infos.current != 0) {
			play_sound(1, true);
		}

		/* We first check the line sensor */
		sensor = light_sensor_status();
		switch(sensor) {
			case 0:
				if(status == STATUS_START) {
					status = STATUS_RUNNING;
				}
				break;

			case 1:
				if(status == STATUS_START) {
					/* ignore*/
				} else if(status == STATUS_RUNNING && elapsed_time > CRITICAL_TIME) {/* Stop on the start area */
					play_sound(2, false);
					skip = true;
					break_loop = true;
				}
				break;

			case 2:
				/* Go backwards */
				skip = true;/* Skip to the next loop iteration */
				set_speed(coords, p_comp, -LOW_SPEED);
				Wait(LINE_BACKWARDS_DURATION);
				set_speed(coords, p_comp, 0);
				set_angle(coords, p_comp, (coords.angle + 90) % 360);/* mmh */
				/* TODO : add a while loop to check the white line again */
				break;

			default:
				break;
		}
		if(!skip) {
			sensor = obstacle_sensors_status();
			switch(sensor) {
				case 1:
				case 2:
				case 5:
					skip = true;/* Skip to the next loop iteration */
					set_speed(coords, p_comp, -LOW_SPEED);
					Wait(OBSTACLE_BACKWARDS_DURATION);
					set_speed(coords, p_comp, 0);
					set_angle(coords, p_comp, (coords.angle + 90 * ((sensor == 1)?1:(-1))) % 360);
					break;

				case 3:
					skip = true;
					set_speed(coords, p_comp, 0);
					set_angle(coords, p_comp, (coords.angle + 60) % 360);
					break;

				case 4:
					skip = true;
					set_speed(coords, p_comp, 0);
					while(obstacle_sensors_status() == sensor) {
						set_angle(coords, p_comp, (coords.angle + 20) % 360);
					}
					break;

				case 0:
				default:
					break;
			}
			if(sensor) {
				play_sound(2, false);
			}
		}

		if(!skip) {
			set_speed(coords, p_comp, REGULAR_SPEED);
		}

		elapsed_time = (CurrentTick() - first_tick) / 1000;
		Wait(WAIT_INTERVAL);
	}

	stop_harvesting();
	set_speed(coords, p_comp, 0);
}
